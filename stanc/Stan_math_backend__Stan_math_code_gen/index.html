<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stan_math_backend__Stan_math_code_gen (stanc.Stan_math_backend__Stan_math_code_gen)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">stanc</a> &#x00BB; Stan_math_backend__Stan_math_code_gen</nav><h1>Module <code>Stan_math_backend__Stan_math_code_gen</code></h1><p>Generate C++ from the MIR.</p><p>This module makes extensive use of the Format<code>0</code> module via the Fmt<code>1</code> API. As such, you'll need to understand the &quot;%a&quot; and &quot;@&quot; notation from <code>0</code>, especially the section headed &quot;Formatted pretty-printing.&quot; Then, we use functions like <code>pf</code> and <code>str</code> from the Fmt library<code>1</code>. On top of that, the &quot;@&quot; pretty-printing specifiers all actually correspond 1-to-1 with commands like <code>open_box</code> from the Format library<code>0</code>. The boxing system is best described in this explainer pdf <code>2</code>, particularly Section 3 (&quot;Format basics&quot;). It's worth noting that someone was able to make a decent-looking pretty-printer for a subset of Javascript<code>3</code> that might serve as a good reference. Good luck!</p><p><code>0</code> Format module doc: https://caml.inria.fr/pub/docs/manual-ocaml/libref/Format.html <code>1</code> Fmt module doc: https://erratique.ch/software/fmt/doc/Fmt.html <code>2</code> Format Unraveled: https://hal.archives-ouvertes.fr/hal-01503081/file/format-unraveled.pdf <code>3</code> Javascript pretty-printer https://github.com/Virum/compiler/blob/28e807b842bab5dcf11460c8193dd5b16674951f/JavaScript.ml#L112</p></header><dl><dt class="spec type" id="type-template"><a href="#type-template" class="anchor"></a><code><span class="keyword">type</span> template</code><code> = </code><table class="variant"><tr id="type-template.Typename" class="anchored"><td class="def constructor"><a href="#type-template.Typename" class="anchor"></a><code>| </code><code><span class="constructor">Typename</span> <span class="keyword">of</span> string</code></td></tr><tr id="type-template.Require" class="anchored"><td class="def constructor"><a href="#type-template.Require" class="anchor"></a><code>| </code><code><span class="constructor">Require</span> <span class="keyword">of</span> string * string</code></td></tr><tr id="type-template.Bool" class="anchored"><td class="def constructor"><a href="#type-template.Bool" class="anchor"></a><code>| </code><code><span class="constructor">Bool</span> <span class="keyword">of</span> string</code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-pp_template"><a href="#val-pp_template" class="anchor"></a><code><span class="keyword">val</span> pp_template : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-template">template</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pp_template_defaults"><a href="#val-pp_template_defaults" class="anchor"></a><code><span class="keyword">val</span> pp_template_defaults : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-template">template</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pp_templates"><a href="#val-pp_templates" class="anchor"></a><code><span class="keyword">val</span> pp_templates : <span>defaults:bool</span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><a href="index.html#type-template">template</a> list</span> <span>&#45;&gt;</span> unit</code></dt></dl><dl><dt class="spec type" id="type-found_functor"><a href="#type-found_functor" class="anchor"></a><code><span class="keyword">type</span> found_functor</code><code> = </code><code>{</code><table class="record"><tr id="type-found_functor.struct_template" class="anchored"><td class="def field"><a href="#type-found_functor.struct_template" class="anchor"></a><code>struct_template : <span><a href="index.html#type-template">template</a> option</span>;</code></td></tr><tr id="type-found_functor.arg_templates" class="anchored"><td class="def field"><a href="#type-found_functor.arg_templates" class="anchor"></a><code>arg_templates : <span><a href="index.html#type-template">template</a> list</span>;</code></td></tr><tr id="type-found_functor.signature" class="anchored"><td class="def field"><a href="#type-found_functor.signature" class="anchor"></a><code>signature : string;</code></td></tr><tr id="type-found_functor.defn" class="anchored"><td class="def field"><a href="#type-found_functor.defn" class="anchor"></a><code>defn : string;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-standalone_functions"><a href="#val-standalone_functions" class="anchor"></a><code><span class="keyword">val</span> standalone_functions : <span>bool Core_kernel.ref</span></code></dt><dt class="spec value" id="val-stanc_args_to_print"><a href="#val-stanc_args_to_print" class="anchor"></a><code><span class="keyword">val</span> stanc_args_to_print : string</code></dt><dt class="spec value" id="val-pp_unused"><a href="#val-pp_unused" class="anchor"></a><code><span class="keyword">val</span> pp_unused : Stdlib.Format.formatter <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pp_function__"><a href="#val-pp_function__" class="anchor"></a><code><span class="keyword">val</span> pp_function__ : Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(string * string)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print name of model function.</p><dl><dt>parameter prog_name</dt><dd><p>Name of the Stan program.</p></dd></dl><dl><dt>parameter fname</dt><dd><p>Name of the function.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_located"><a href="#val-pp_located" class="anchor"></a><code><span class="keyword">val</span> pp_located : Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the body of exception handling for functions</p></dd></dl><dl><dt class="spec value" id="val-arg_needs_template"><a href="#val-arg_needs_template" class="anchor"></a><code><span class="keyword">val</span> arg_needs_template : <span>(<a href="../Middle/UnsizedType/index.html#type-autodifftype">Middle.UnsizedType.autodifftype</a> * <span class="type-var">'a</span> * <a href="../Middle/UnsizedType/index.html#type-t">Middle.UnsizedType.t</a>)</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Detect if argument requires C++ template</p></dd></dl><dl><dt class="spec value" id="val-maybe_templated_arg_types"><a href="#val-maybe_templated_arg_types" class="anchor"></a><code><span class="keyword">val</span> maybe_templated_arg_types : <a href="../Middle/Program/index.html#type-fun_arg_decl">Middle.Program.fun_arg_decl</a> <span>&#45;&gt;</span> <span><span>string option</span> list</span></code></dt><dd><p>Print template arguments for C++ functions that need templates</p><dl><dt>parameter args</dt><dd><p>A pack of <code>Program.fun_arg_decl</code> containing functions to detect templates.</p></dd></dl><dl><dt>returns</dt><dd><p>A list of arguments with template parameter names added.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-maybe_require_templates"><a href="#val-maybe_require_templates" class="anchor"></a><code><span class="keyword">val</span> maybe_require_templates : <span><span>string option</span> list</span> <span>&#45;&gt;</span> <a href="../Middle/Program/index.html#type-fun_arg_decl">Middle.Program.fun_arg_decl</a> <span>&#45;&gt;</span> <span><span><a href="index.html#type-template">template</a> option</span> list</span></code></dt><dt class="spec value" id="val-return_arg_types"><a href="#val-return_arg_types" class="anchor"></a><code><span class="keyword">val</span> return_arg_types : <a href="../Middle/Program/index.html#type-fun_arg_decl">Middle.Program.fun_arg_decl</a> <span>&#45;&gt;</span> <span><span>string option</span> list</span></code></dt><dt class="spec value" id="val-pp_promoted_scalar"><a href="#val-pp_promoted_scalar" class="anchor"></a><code><span class="keyword">val</span> pp_promoted_scalar : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="../Middle/Program/index.html#type-fun_arg_decl">Middle.Program.fun_arg_decl</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the code for promoting stan real types</p><dl><dt>parameter ppf</dt><dd><p>A pretty printer</p></dd></dl><dl><dt>parameter args</dt><dd><p>A pack of arguments to detect whether they need to use the promotion rules.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_returntype"><a href="#val-pp_returntype" class="anchor"></a><code><span class="keyword">val</span> pp_returntype : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="../Middle/Program/index.html#type-fun_arg_decl">Middle.Program.fun_arg_decl</a> <span>&#45;&gt;</span> <span><a href="../Middle/UnsizedType/index.html#type-t">Middle.UnsizedType.t</a> option</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-prints a function's return-type, taking into account templated argument promotion.</p></dd></dl><dl><dt class="spec value" id="val-pp_eigen_arg_to_ref"><a href="#val-pp_eigen_arg_to_ref" class="anchor"></a><code><span class="keyword">val</span> pp_eigen_arg_to_ref : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * string * <a href="../Middle/UnsizedType/index.html#type-t">Middle.UnsizedType.t</a>)</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pp_located_error"><a href="#val-pp_located_error" class="anchor"></a><code><span class="keyword">val</span> pp_located_error : Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> * <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_located_error ppf (pp_body_block, body_block, err_msg)</code> surrounds <code>body_block</code> with a C++ try-catch that will rethrow the error with the proper source location from the <code>body_block</code> (required to be a <code>stmt_loc Block</code> variant).</p><dl><dt>parameter ppf</dt><dd><p>A pretty printer.</p></dd></dl><dl><dt>parameter pp_body_block</dt><dd><p>A pretty printer for the body block</p></dd></dl><dl><dt>parameter body</dt><dd><p>A C++ scoped body block surrounded by squiggly braces.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_arg"><a href="#val-pp_arg" class="anchor"></a><code><span class="keyword">val</span> pp_arg : Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(<span>string option</span> * <span>(<span class="type-var">'a</span> * string * <a href="../Middle/UnsizedType/index.html#type-t">Middle.UnsizedType.t</a>)</span>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the type of an object.</p><dl><dt>parameter ppf</dt><dd><p>A pretty printer</p></dd></dl><dl><dt>parameter custom_scalar_opt</dt><dd><p>A string representing a types inner scalar value.</p></dd></dl><dl><dt>parameter name</dt><dd><p>The name of the object</p></dd></dl><dl><dt>parameter ut</dt><dd><p>The unsized type of the object</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_arg_eigen_suffix"><a href="#val-pp_arg_eigen_suffix" class="anchor"></a><code><span class="keyword">val</span> pp_arg_eigen_suffix : Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(<span>string option</span> * <span>(<span class="type-var">'a</span> * string * <a href="../Middle/UnsizedType/index.html#type-t">Middle.UnsizedType.t</a>)</span>)</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pp_located_error_b"><a href="#val-pp_located_error_b" class="anchor"></a><code><span class="keyword">val</span> pp_located_error_b : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span><span>(<a href="../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>, <a href="../Middle__Stmt/Numbered/Meta/index.html#type-t">Middle.Stmt.Numbered.Meta.t</a>)</span> <a href="../Middle__Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span> list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_located_error_b</code> automatically adds a Block wrapper</p></dd></dl><dl><dt class="spec value" id="val-typename"><a href="#val-typename" class="anchor"></a><code><span class="keyword">val</span> typename : string <span>&#45;&gt;</span> <a href="index.html#type-template">template</a></code></dt><dt class="spec value" id="val-get_templates_and_args"><a href="#val-get_templates_and_args" class="anchor"></a><code><span class="keyword">val</span> get_templates_and_args : bool <span>&#45;&gt;</span> <a href="../Middle/Program/index.html#type-fun_arg_decl">Middle.Program.fun_arg_decl</a> <span>&#45;&gt;</span> <span>string list</span> * <span><a href="index.html#type-template">template</a> list</span> * <span>string list</span></code></dt><dd><p>Construct an object with it's needed templates for function signatures.</p><dl><dt>parameter fdargs</dt><dd><p>A sexp list of strings representing C++ types.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_template_decorator"><a href="#val-pp_template_decorator" class="anchor"></a><code><span class="keyword">val</span> pp_template_decorator : Stdlib.Format.formatter <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the C++ template parameter decleration before a function.</p><dl><dt>parameter ppf</dt><dd><p>A pretty printer.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mk_extra_args"><a href="#val-mk_extra_args" class="anchor"></a><code><span class="keyword">val</span> mk_extra_args : <span>string list</span> <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> <span>string list</span></code></dt><dt class="spec value" id="val-pp_fun_def"><a href="#val-pp_fun_def" class="anchor"></a><code><span class="keyword">val</span> pp_fun_def : Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(<span><span><span>(<a href="../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>, <a href="../Middle__Stmt/Numbered/Meta/index.html#type-t">Middle.Stmt.Numbered.Meta.t</a>)</span> <a href="../Middle__Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span> <a href="../Middle/Program/index.html#type-fun_def">Middle.Program.fun_def</a></span> * <span><span>(string, <span><a href="index.html#type-found_functor">found_functor</a> list</span>)</span> Core_kernel.Hashtbl.t</span> * <span><span>(string * <span><a href="index.html#type-template">template</a> list</span>)</span> Core_kernel.Hash_set.t</span> * Core_kernel.String.Set.t * Core_kernel.String.Set.t * Core_kernel.String.Set.t)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the C++ function definition.</p><dl><dt>parameter ppf</dt><dd><p>A pretty printer Refactor this please - one idea might be to have different functions for printing user defined distributions vs rngs vs regular functions.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_standalone_fun_def"><a href="#val-pp_standalone_fun_def" class="anchor"></a><code><span class="keyword">val</span> pp_standalone_fun_def : string <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Middle/Program/index.html#type-fun_def">Middle.Program.fun_def</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Creates functions outside the model namespaces which only call the ones inside the namespaces</p></dd></dl><dl><dt class="spec value" id="val-version"><a href="#val-version" class="anchor"></a><code><span class="keyword">val</span> version : string</code></dt><dt class="spec value" id="val-includes"><a href="#val-includes" class="anchor"></a><code><span class="keyword">val</span> includes : string</code></dt><dt class="spec value" id="val-pp_validate_data"><a href="#val-pp_validate_data" class="anchor"></a><code><span class="keyword">val</span> pp_validate_data : Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(string * <span><a href="../Middle__Expr/Typed/index.html#type-t">Middle__Expr.Typed.t</a> <a href="../Middle/SizedType/index.html#type-t">Middle.SizedType.t</a></span>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Validate the dimensions of the C++ object are correct at runtime</p><dl><dt>parameter ppf</dt><dd><p>A pretty printer</p></dd></dl><dl><dt>parameter name</dt><dd><p>The name of the object.</p></dd></dl><dl><dt>parameter st</dt><dd><p>The SizedType of the object.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_mul"><a href="#val-pp_mul" class="anchor"></a><code><span class="keyword">val</span> pp_mul : Stdlib.Format.formatter <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-get_unconstrained_param_st"><a href="#val-get_unconstrained_param_st" class="anchor"></a><code><span class="keyword">val</span> get_unconstrained_param_st : <span>(<span class="type-var">'a</span> * <span><a href="../Middle__Expr/Typed/index.html#type-t">Middle__Expr.Typed.t</a> <a href="../Middle/Program/index.html#type-outvar">Middle.Program.outvar</a></span>)</span> <span>&#45;&gt;</span> <span><span><a href="../Middle__Expr/Typed/index.html#type-t">Middle__Expr.Typed.t</a> list</span> option</span></code></dt><dt class="spec value" id="val-get_constrained_param_st"><a href="#val-get_constrained_param_st" class="anchor"></a><code><span class="keyword">val</span> get_constrained_param_st : <span>(<span class="type-var">'a</span> * <span><a href="../Middle__Expr/Typed/index.html#type-t">Middle__Expr.Typed.t</a> <a href="../Middle/Program/index.html#type-outvar">Middle.Program.outvar</a></span>)</span> <span>&#45;&gt;</span> <span><span><a href="../Middle__Expr/Typed/index.html#type-t">Middle__Expr.Typed.t</a> list</span> option</span></code></dt><dt class="spec value" id="val-pp_num_param"><a href="#val-pp_num_param" class="anchor"></a><code><span class="keyword">val</span> pp_num_param : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><a href="../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pp_ctor"><a href="#val-pp_ctor" class="anchor"></a><code><span class="keyword">val</span> pp_ctor : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<a href="../Middle__Expr/Typed/index.html#type-t">Middle__Expr.Typed.t</a>, <span><span>(<a href="../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>, <a href="../Middle__Stmt/Numbered/Meta/index.html#type-t">Middle.Stmt.Numbered.Meta.t</a>)</span> <a href="../Middle__Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the constructor of the model class. Read in data steps: 1. context__.validate_dims() to verify the dimensions are correct at runtime. 1. find vals_%s__ from context__.vals_%s(vident) 1. keep track of pos__ 1. run checks on resulting vident</p></dd></dl><dl><dt class="spec value" id="val-top_level_decls"><a href="#val-top_level_decls" class="anchor"></a><code><span class="keyword">val</span> top_level_decls : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Middle__Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span> <span>&#45;&gt;</span> <span><span>(string * <a href="../Middle/UnsizedType/index.html#type-t">Middle.UnsizedType.t</a>)</span> list</span></code></dt><dt class="spec value" id="val-pp_model_private"><a href="#val-pp_model_private" class="anchor"></a><code><span class="keyword">val</span> pp_model_private : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <a href="../Middle__Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the private data members of the model class</p></dd></dl><dl><dt class="spec value" id="val-pp_method"><a href="#val-pp_method" class="anchor"></a><code><span class="keyword">val</span> pp_method : Stdlib.Format.formatter <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> <span>(Stdlib.Format.formatter <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span>?&#8288;outro:<span>unit Fmt.t</span></span> <span>&#45;&gt;</span> <span>?&#8288;cv_attr:<span>string list</span></span> <span>&#45;&gt;</span> <span>(Stdlib.Format.formatter <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the signature and blocks of the model class methods.</p><dl><dt>parameter ppf</dt><dd><p>A pretty printer</p></dd></dl><dl><dt>parameter rt</dt><dd><p>The return type.</p></dd></dl><dl><dt>parameter name</dt><dd><p>The method name.</p></dd></dl><dl><dt>parameter intro</dt><dd><p>Anything that needs printed before the method body.</p></dd></dl><dl><dt>parameter outro</dt><dd><p>Anything that needs printed after the method body.</p></dd></dl><dl><dt>parameter cv_attr</dt><dd><p>Optional parameter to add method attributes.</p></dd></dl><dl><dt>parameter ppbody</dt><dd><p>(?A pretty printer of the method's body)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_get_param_names"><a href="#val-pp_get_param_names" class="anchor"></a><code><span class="keyword">val</span> pp_get_param_names : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the <code>get_param_names</code> method of the model class</p><dl><dt>parameter ppf</dt><dd><p>A pretty printer.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_get_dims"><a href="#val-pp_get_dims" class="anchor"></a><code><span class="keyword">val</span> pp_get_dims : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<a href="../Middle__Expr/Typed/index.html#type-t">Middle__Expr.Typed.t</a>, <span class="type-var">'a</span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the <code>get_dims</code> method of the model class.</p></dd></dl><dl><dt class="spec value" id="val-pp_method_b"><a href="#val-pp_method_b" class="anchor"></a><code><span class="keyword">val</span> pp_method_b : Stdlib.Format.formatter <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> <span>(Stdlib.Format.formatter <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span>?&#8288;outro:<span>unit Fmt.t</span></span> <span>&#45;&gt;</span> <span>?&#8288;cv_attr:<span>string list</span></span> <span>&#45;&gt;</span> <span><span><span>(<a href="../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>, <a href="../Middle__Stmt/Numbered/Meta/index.html#type-t">Middle.Stmt.Numbered.Meta.t</a>)</span> <a href="../Middle__Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pp_write_array"><a href="#val-pp_write_array" class="anchor"></a><code><span class="keyword">val</span> pp_write_array : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span><span>(<a href="../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>, <a href="../Middle__Stmt/Numbered/Meta/index.html#type-t">Middle.Stmt.Numbered.Meta.t</a>)</span> <a href="../Middle__Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the write_array method of the model class</p></dd></dl><dl><dt class="spec value" id="val-pp_for_loop_iteratee"><a href="#val-pp_for_loop_iteratee" class="anchor"></a><code><span class="keyword">val</span> pp_for_loop_iteratee : <span>?&#8288;index_ids:<span>string list</span></span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> * <span><a href="../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> * <span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> * <span>string list</span>)</span> <span>&#45;&gt;</span> unit)</span>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Prints the for loop for <code>constrained_param_names</code> and <code>unconstrained_param_names</code></p><dl><dt>parameter index_ids</dt><dd><p>Optional named parameter of a SizedType's dimensions</p></dd></dl><dl><dt>parameter ppf</dt><dd><p>A pretty printer</p></dd></dl><dl><dt>parameter dims</dt><dd><p>A list of the dimensions of a SizedType</p></dd></dl><dl><dt>parameter pp_body</dt><dd><p>Pretty printer for the body of the loop.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-emit_name"><a href="#val-emit_name" class="anchor"></a><code><span class="keyword">val</span> emit_name : Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(string * <span>string list</span>)</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-emit_complex_name"><a href="#val-emit_complex_name" class="anchor"></a><code><span class="keyword">val</span> emit_complex_name : Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(string * <span>string list</span>)</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pp_constrained_param_names"><a href="#val-pp_constrained_param_names" class="anchor"></a><code><span class="keyword">val</span> pp_constrained_param_names : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<a href="../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a>, <span class="type-var">'a</span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the <code>constrained_param_names</code> method of the model class.</p></dd></dl><dl><dt class="spec value" id="val-pp_unconstrained_param_names"><a href="#val-pp_unconstrained_param_names" class="anchor"></a><code><span class="keyword">val</span> pp_unconstrained_param_names : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<a href="../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a>, <span class="type-var">'a</span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the <code>unconstrained_param_names</code> method of the model class. This is just a copy of constrained, I need to figure out which one is wrong and fix it eventually. From Bob,</p><p>Off the top of my head, I think the four that change sizes from constrained to unconstrained are:</p><p>simplex: K -&gt; (K - 1) covar_matrix: K^2 -&gt; (K choose 2) + K corr_matrix: K^2 -&gt; (K choose 2) cholesky_corr: (K choose 2) + K -&gt; (K choose 2)</p><p>cholesky_cov does not change size (it's (K choose 2) + K). Now that our unit vector uses the normal thing, that also doesn't change size. The ordered types and constrained types don't change sizes either.</p></dd></dl><dl><dt class="spec value" id="val-pp_transform_inits_impl"><a href="#val-pp_transform_inits_impl" class="anchor"></a><code><span class="keyword">val</span> pp_transform_inits_impl : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span><span>(<a href="../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>, <a href="../Middle__Stmt/Numbered/Meta/index.html#type-t">Middle.Stmt.Numbered.Meta.t</a>)</span> <a href="../Middle__Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the <code>transform_inits</code> method of the model class</p></dd></dl><dl><dt class="spec value" id="val-pp_log_prob"><a href="#val-pp_log_prob" class="anchor"></a><code><span class="keyword">val</span> pp_log_prob : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span><span>(<a href="../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>, <a href="../Middle__Stmt/Numbered/Meta/index.html#type-t">Middle.Stmt.Numbered.Meta.t</a>)</span> <a href="../Middle__Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the <code>log_prob</code> method of the model class</p></dd></dl><dl><dt class="spec value" id="val-pp_outvar_metadata"><a href="#val-pp_outvar_metadata" class="anchor"></a><code><span class="keyword">val</span> pp_outvar_metadata : Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(string * <span><span>(string * <span><a href="../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../Middle/SizedType/index.html#type-t">Middle.SizedType.t</a></span> * <a href="../Middle/Program/index.html#type-io_block">Middle.Program.io_block</a>)</span> list</span>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the body of the constrained and unconstrained sizedtype methods in the model class</p><dl><dt>parameter ppf</dt><dd><p>A pretty printer</p></dd></dl><dl><dt>parameter method_name</dt><dd><p>The name of the method to wrap the body in.</p></dd></dl><dl><dt>parameter outvars</dt><dd><p>The parameters to gather the sizes for.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_unconstrained_types"><a href="#val-pp_unconstrained_types" class="anchor"></a><code><span class="keyword">val</span> pp_unconstrained_types : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<a href="../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a>, <span class="type-var">'a</span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the <code>get_unconstrained_sizedtypes</code> method of the model class</p></dd></dl><dl><dt class="spec value" id="val-pp_constrained_types"><a href="#val-pp_constrained_types" class="anchor"></a><code><span class="keyword">val</span> pp_constrained_types : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<a href="../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a>, <span class="type-var">'a</span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the <code>get_constrained_sizedtypes</code> method of the model class</p></dd></dl><dl><dt class="spec value" id="val-pp_overloads"><a href="#val-pp_overloads" class="anchor"></a><code><span class="keyword">val</span> pp_overloads : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<a href="../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a>, <span class="type-var">'a</span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the generic method overloads needed in the model class.</p></dd></dl><dl><dt class="spec value" id="val-pp_transform_inits"><a href="#val-pp_transform_inits" class="anchor"></a><code><span class="keyword">val</span> pp_transform_inits : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<a href="../Middle__Expr/Typed/index.html#type-t">Middle__Expr.Typed.t</a>, <span class="type-var">'a</span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the <code>get_constrained_sizedtypes</code> method of the model class</p></dd></dl><dl><dt class="spec value" id="val-pp_model_public"><a href="#val-pp_model_public" class="anchor"></a><code><span class="keyword">val</span> pp_model_public : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<a href="../Middle__Expr/Typed/index.html#type-t">Middle__Expr.Typed.t</a>, <span><span>(<a href="../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>, <a href="../Middle__Stmt/Numbered/Meta/index.html#type-t">Middle.Stmt.Numbered.Meta.t</a>)</span> <a href="../Middle__Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the public parts of the model class</p></dd></dl><dl><dt class="spec value" id="val-model_prefix"><a href="#val-model_prefix" class="anchor"></a><code><span class="keyword">val</span> model_prefix : string</code></dt><dt class="spec value" id="val-pp_model"><a href="#val-pp_model" class="anchor"></a><code><span class="keyword">val</span> pp_model : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<a href="../Middle__Expr/Typed/index.html#type-t">Middle__Expr.Typed.t</a>, <span><span>(<a href="../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>, <a href="../Middle__Stmt/Numbered/Meta/index.html#type-t">Middle.Stmt.Numbered.Meta.t</a>)</span> <a href="../Middle__Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the full model class.</p></dd></dl><dl><dt class="spec value" id="val-usings"><a href="#val-usings" class="anchor"></a><code><span class="keyword">val</span> usings : string</code></dt><dt class="spec value" id="val-namespace"><a href="#val-namespace" class="anchor"></a><code><span class="keyword">val</span> namespace : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> string</code></dt><dd><p>Create the model's namespace.</p></dd></dl><dl><dt class="spec value" id="val-pp_register_map_rect_functors"><a href="#val-pp_register_map_rect_functors" class="anchor"></a><code><span class="keyword">val</span> pp_register_map_rect_functors : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Find and register functiors used for map_rect.</p></dd></dl><dl><dt class="spec value" id="val-is_fun_used_with_variadic_fn"><a href="#val-is_fun_used_with_variadic_fn" class="anchor"></a><code><span class="keyword">val</span> is_fun_used_with_variadic_fn : <span>(string <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span>(<span><span class="type-var">'a</span> <a href="../Middle__Expr/Fixed/index.html#type-t">Middle.Expr.Fixed.t</a></span>, <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <a href="../Middle__Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> Core_kernel.String.Set.t</code></dt><dt class="spec value" id="val-collect_functors_functions"><a href="#val-collect_functors_functions" class="anchor"></a><code><span class="keyword">val</span> collect_functors_functions : <span><span>(<span><span class="type-var">'a</span> <a href="../Middle__Expr/Fixed/index.html#type-t">Middle.Expr.Fixed.t</a></span>, <span><span>(<a href="../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>, <a href="../Middle__Stmt/Numbered/Meta/index.html#type-t">Middle.Stmt.Numbered.Meta.t</a>)</span> <a href="../Middle__Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span>)</span> <a href="../Middle/Program/index.html#type-t">Middle.Program.t</a></span> <span>&#45;&gt;</span> string * <span><span>(string, <span><a href="index.html#type-found_functor">found_functor</a> list</span>)</span> Core_kernel.Hashtbl.t</span></code></dt><dt class="spec value" id="val-pp_prog"><a href="#val-pp_prog" class="anchor"></a><code><span class="keyword">val</span> pp_prog : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="../Middle__Program/Typed/index.html#type-t">Middle.Program.Typed.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the full C++ for the stan program.</p></dd></dl></div></body></html>