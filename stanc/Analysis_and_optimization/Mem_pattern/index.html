<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mem_pattern (stanc.Analysis_and_optimization.Mem_pattern)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">stanc</a> &#x00BB; <a href="../index.html">Analysis_and_optimization</a> &#x00BB; Mem_pattern</nav><h1>Module <code>Analysis_and_optimization.Mem_pattern</code></h1></header><dl><dt class="spec value" id="val-matrix_set"><a href="#val-matrix_set" class="anchor"></a><code><span class="keyword">val</span> matrix_set : <span><a href="../../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a> <a href="../../Middle__Expr/Fixed/index.html#type-t">Middle.Expr.Fixed.t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../Dataflow_types/index.html#type-vexpr">Dataflow_types.vexpr</a> * <a href="../../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>)</span> Core_kernel.Set.Poly.t</span></code></dt><dd><p>* Return a Var expression of the name for each type * containing an eigen matrix</p></dd></dl><dl><dt class="spec value" id="val-query_var_eigen_names"><a href="#val-query_var_eigen_names" class="anchor"></a><code><span class="keyword">val</span> query_var_eigen_names : <a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span></code></dt><dd><p>* Return a set of all types containing autodiffable Eigen matrices * in an expression.</p></dd></dl><dl><dt class="spec value" id="val-is_nonzero_subset"><a href="#val-is_nonzero_subset" class="anchor"></a><code><span class="keyword">val</span> is_nonzero_subset : <span>set:<span><span class="type-var">'a</span> Core_kernel.Set.Poly.t</span></span> <span>&#45;&gt;</span> <span>subset:<span><span class="type-var">'a</span> Core_kernel.Set.Poly.t</span></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>* Check whether one set is a nonzero subset of another set.</p></dd></dl><dl><dt class="spec value" id="val-count_single_idx_exprs"><a href="#val-count_single_idx_exprs" class="anchor"></a><code><span class="keyword">val</span> count_single_idx_exprs : int <span>&#45;&gt;</span> <a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>* Check an expression to count how many times we see a single index. * </p><dl><dt>parameter acc</dt><dd><p>An accumulator from previous folds of multiple expressions. * </p><p>@param pattern</p><p>The expression patterns to match against</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-count_single_idx"><a href="#val-count_single_idx" class="anchor"></a><code><span class="keyword">val</span> count_single_idx : int <span>&#45;&gt;</span> <span><span><a href="../../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a> <a href="../../Middle__Expr/Fixed/index.html#type-t">Middle.Expr.Fixed.t</a></span> <a href="../../Middle/Index/index.html#type-t">Middle.Index.t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>* Check an Index to count how many times we see a single index. * </p><dl><dt>parameter acc</dt><dd><p>An accumulator from previous folds of multiple expressions. * </p><p>@param idx</p><p>An Index to match. For Single types this adds 1 to the * acc. For Upfrom and MultiIndex types we check the inner expression * for a Single index. All and Between cannot be Single cell access * and so pass acc along.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_uni_eigen_loop_indexing"><a href="#val-is_uni_eigen_loop_indexing" class="anchor"></a><code><span class="keyword">val</span> is_uni_eigen_loop_indexing : bool <span>&#45;&gt;</span> <a href="../../Middle/UnsizedType/index.html#type-t">Middle.UnsizedType.t</a> <span>&#45;&gt;</span> <span><span><a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../../Middle/Index/index.html#type-t">Middle.Index.t</a></span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>* Find indices on Matrix and Vector types that perform single * cell access. Returns true if it finds * a vector, row vector, matrix, or matrix with single cell access * as well as an array of any of the above that is accessing the * inner matrix types cell. * </p><dl><dt>parameter ut</dt><dd><p>An UnsizedType to match against. * </p><p>@param index</p><p>This list is checked for Single cell access * either at the top level or within the `Index` types of the list.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-query_stan_math_mem_pattern_support"><a href="#val-query_stan_math_mem_pattern_support" class="anchor"></a><code><span class="keyword">val</span> query_stan_math_mem_pattern_support : string <span>&#45;&gt;</span> <span><span>(<a href="../../Middle/UnsizedType/index.html#type-autodifftype">Middle.UnsizedType.autodifftype</a> * <a href="../../Middle/UnsizedType/index.html#type-t">Middle.UnsizedType.t</a>)</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_fun_soa_supported"><a href="#val-is_fun_soa_supported" class="anchor"></a><code><span class="keyword">val</span> is_fun_soa_supported : string <span>&#45;&gt;</span> <span><a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-query_initial_demotable_expr"><a href="#val-query_initial_demotable_expr" class="anchor"></a><code><span class="keyword">val</span> query_initial_demotable_expr : bool <span>&#45;&gt;</span> <span>acc:<span>string Core_kernel.Set.Poly.t</span></span> <span>&#45;&gt;</span> <a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span></code></dt><dd><p>* Query to find the initial set of objects that cannot be SoA. * This is mostly recursing over expressions, with the exceptions * being functions and indexing expressions. For the logic on functions * see the docs for `query_initial_demotable_funs`. * </p><dl><dt>parameter in_loop</dt><dd><p>a boolean to signify if the expression exists inside * of a loop. If so, the names of matrix and vector like objects * will be returned if the matrix or vector is accessed by single * cell indexing.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-query_initial_demotable_funs"><a href="#val-query_initial_demotable_funs" class="anchor"></a><code><span class="keyword">val</span> query_initial_demotable_funs : bool <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <span><span><a href="../../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a> <a href="../../Middle__Expr/Fixed/index.html#type-t">Middle.Expr.Fixed.t</a></span> <a href="../../Middle/Fun_kind/index.html#type-t">Middle.Fun_kind.t</a></span> <span>&#45;&gt;</span> <span><a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span></code></dt><dd><p>* Query a function to detect if it or any of its used * expression's objects or expressions should be demoted to AoS. * * The logic here demotes the expressions in a function to AoS if * the function's inner expression returns has a meta type containing a matrix * and either of : * (1) The function is user defined and the UDFs inputs are matrices. * (2) The Stan math function cannot support AoS * </p><dl><dt>parameter in_loop</dt><dd><p>A boolean to specify the logic of indexing expressions. See * `query_initial_demotable_expr` for an explanation of the logic. * </p><p>@param kind</p><p>The function type, for StanLib functions we check if the * function supports SoA and for UserDefined functions we always fail * and return back all of the names of the objects passed in expressions * to the UDF. * exprs The expression list passed to the functions.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_any_soa_supported_expr"><a href="#val-is_any_soa_supported_expr" class="anchor"></a><code><span class="keyword">val</span> is_any_soa_supported_expr : <a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>* Check whether any functions in the right hand side expression of an assignment * support SoA. If so then return true, otherwise return false.</p></dd></dl><dl><dt class="spec value" id="val-is_any_soa_supported_fun_expr"><a href="#val-is_any_soa_supported_fun_expr" class="anchor"></a><code><span class="keyword">val</span> is_any_soa_supported_fun_expr : <span><span><a href="../../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a> <a href="../../Middle__Expr/Fixed/index.html#type-t">Middle.Expr.Fixed.t</a></span> <a href="../../Middle/Fun_kind/index.html#type-t">Middle.Fun_kind.t</a></span> <span>&#45;&gt;</span> <span><a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>* Return false if the `Fun_kind.t` does not support `SoA`</p></dd></dl><dl><dt class="spec value" id="val-is_any_ad_real_data_matrix_expr"><a href="#val-is_any_ad_real_data_matrix_expr" class="anchor"></a><code><span class="keyword">val</span> is_any_ad_real_data_matrix_expr : <a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>* Return true if the rhs expression of an assignment contains only * combinations of AutoDiffable Reals and Data Matrices</p></dd></dl><dl><dt class="spec value" id="val-is_any_ad_real_data_matrix_expr_fun"><a href="#val-is_any_ad_real_data_matrix_expr_fun" class="anchor"></a><code><span class="keyword">val</span> is_any_ad_real_data_matrix_expr_fun : <span><span><a href="../../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a> <a href="../../Middle__Expr/Fixed/index.html#type-t">Middle.Expr.Fixed.t</a></span> <a href="../../Middle/Fun_kind/index.html#type-t">Middle.Fun_kind.t</a></span> <span>&#45;&gt;</span> <span><a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>* Return true if the expressions in a function call are all * combinations of AutoDiffable Reals and Data Matrices</p></dd></dl><dl><dt class="spec value" id="val-query_initial_demotable_stmt"><a href="#val-query_initial_demotable_stmt" class="anchor"></a><code><span class="keyword">val</span> query_initial_demotable_stmt : bool <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <span><span>(<a href="../../Middle__Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>,Â <a href="../../Middle__Stmt/Located/Meta/index.html#type-t">Middle.Stmt.Located.Meta.t</a>)</span> <a href="../../Middle__Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span></code></dt><dd><p>* Query to find the initial set of objects in statements that cannot be SoA. * This is mostly recursive over expressions and statements, with the exception of * functions and Assignments. * * For assignments: * We demote the LHS variable if any of the following are true: * 1. None of the RHS's functions are able to accept SoA matrices * and the rhs is not an internal compiler function. * 2. A single cell of the LHS is being assigned within a loop. * 3. The top level expression on the RHS is a combination of only * data matrices and scalar types. Operations on data matrix and * scalar values in Stan math will return a AoS matrix. We currently * have no way to tell Stan math to return a SoA matrix. * * We demote RHS variables if any of the following are true: * 1. The LHS variable has previously or through this iteration * been marked AoS. * * For functions see the documentation for `query_initial_demotable_funs` for * the logic on demotion rules. * </p><dl><dt>parameter in_loop</dt><dd><p>A boolean to specify the logic of indexing expressions. See * `query_initial_demotable_expr` for an explanation of the logic.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-query_demotable_stmt"><a href="#val-query_demotable_stmt" class="anchor"></a><code><span class="keyword">val</span> query_demotable_stmt : <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <span><span>(<a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a>,Â int)</span> <a href="../../Middle__Stmt/Fixed/Pattern/index.html#type-t">Middle.Stmt.Fixed.Pattern.t</a></span> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span></code></dt><dd><p>Look through a statement to see whether the objects used in it need to be * modified from SoA to AoS. Returns the set of object names that need demoted * in a statement, if any. * This function looks at Assignment statements, and returns back the * set of top level object names given: * 1. If the name of the lhs assignee is in the `aos_exits`, all the names * of the expressions with a type containing a matrix are returned. * 2. If the names of the rhs objects containing matrix types are in the subset of * aos_exits. * </p><dl><dt>parameter aos_exits</dt><dd><p>A set of variables that can be demoted. * </p><p>@param pattern</p><p>The Stmt pattern to query.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_kind"><a href="#val-modify_kind" class="anchor"></a><code><span class="keyword">val</span> modify_kind : <span>?&#8288;force_demotion:bool</span> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <span><a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../../Middle/Fun_kind/index.html#type-t">Middle.Fun_kind.t</a></span> <span>&#45;&gt;</span> <span><a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span>&#45;&gt;</span> <span><a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../../Middle/Fun_kind/index.html#type-t">Middle.Fun_kind.t</a></span> * <span><a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span></code></dt><dd><p>* Modify a function and it's subexpressions from SoA &lt;-&gt; AoS and vice versa. * This performs demotion for sub expressions recursively. The top level * expression and it's sub expressions are demoted to SoA if * 1. The names of the variables in the subexpressions returning * objects holding matrices are all in the modifiable set. * 2. The function does not support SoA * 3. The `force` argument is `true` * </p><dl><dt>parameter force_demotion</dt><dd><p>If true, forces an expression and it's sub-expressions * to be AoS. * </p><p>@param modifiable_set</p><p>The set of names that are either demotable * to AoS or promotable to SoA. * </p><p>@param kind</p><p>A `Fun_kind.t` * </p><p>@param exprs</p><p>A list of expressions going into the function. *</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_expr_pattern"><a href="#val-modify_expr_pattern" class="anchor"></a><code><span class="keyword">val</span> modify_expr_pattern : <span>?&#8288;force_demotion:bool</span> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <span><a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../../Middle__Expr/Fixed/Pattern/index.html#type-t">Middle.Expr.Fixed.Pattern.t</a></span> <span>&#45;&gt;</span> <span><a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../../Middle__Expr/Fixed/Pattern/index.html#type-t">Middle.Expr.Fixed.Pattern.t</a></span></code></dt><dd><p>* Modify an expression and it's subexpressions from SoA &lt;-&gt; AoS * and vice versa. The only real paths in the below is on the * functions and ternary expressions. * * The logic for functions is defined in `modify_kind`. * `TernaryIf` is forcefully demoted to AoS if the type of the expression * contains a matrix. * </p><dl><dt>parameter force_demotion</dt><dd><p>If true, forces an expression and it's sub-expressions * to be AoS. * </p><p>@param modifiable_set</p><p>The name of the variables whose * associated expressions we want to modify. * </p><p>@param pattern</p><p>The expression to modify.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_expr"><a href="#val-modify_expr" class="anchor"></a><code><span class="keyword">val</span> modify_expr : <span>?&#8288;force_demotion:bool</span> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span>&#45;&gt;</span> <a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a></code></dt><dd><p>* Given a Set of strings containing the names of objects that can be * modified from AoS &lt;-&gt; SoA and vice versa, modify them within the expression. * </p><dl><dt>parameter mem_pattern</dt><dd><p>The memory pattern to change expressions to. * </p><p>@param modifiable_set</p><p>The name of the variables whose * associated expressions we want to modify. * </p><p>@param expr</p><p>the expression to modify.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_stmt_pattern"><a href="#val-modify_stmt_pattern" class="anchor"></a><code><span class="keyword">val</span> modify_stmt_pattern : <span><span>(<a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a>,Â <a href="../../Middle__Stmt/Located/index.html#type-t">Middle.Stmt.Located.t</a>)</span> <a href="../../Middle__Stmt/Fixed/Pattern/index.html#type-t">Middle.Stmt.Fixed.Pattern.t</a></span> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <span><span>(<a href="../../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a>,Â <a href="../../Middle__Stmt/Located/index.html#type-t">Middle.Stmt.Located.t</a>)</span> <a href="../../Middle__Stmt/Fixed/Pattern/index.html#type-t">Middle.Stmt.Fixed.Pattern.t</a></span></code></dt><dd><p>* Modify statement patterns in the MIR from AoS &lt;-&gt; SoA and vice versa * For `Decl` and `Assignment`'s reading in parameters, we demote to AoS * if the `decl_id` (or assign name) is in the modifiable set and * otherwise promote the statement to `SoA`. * For general `Assignment` statements, we check if the assignee is in * the demotable set. If so, we force demotion of all of the rhs expressions. * All other statements recurse over their statements and expressions. * * </p><dl><dt>parameter pattern</dt><dd><p>The statement pattern to modify * </p><p>@param modifiable_set</p><p>The name of the variable we are searching for.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_stmt"><a href="#val-modify_stmt" class="anchor"></a><code><span class="keyword">val</span> modify_stmt : <a href="../../Middle__Stmt/Located/index.html#type-t">Middle.Stmt.Located.t</a> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <a href="../../Middle__Stmt/Located/index.html#type-t">Middle.Stmt.Located.t</a></code></dt><dd><p>* Modify statement patterns in the MIR from AoS &lt;-&gt; SoA and vice versa * </p><dl><dt>parameter mem_pattern</dt><dd><p>A mem_pattern to modify expressions to. For the * given memory pattern, this modifies * statement patterns and expressions to it. * </p><p>@param stmt</p><p>The statement to modify. * </p><p>@param modifiable_set</p><p>The name of the variable we are searching for.</p></dd></dl></dd></dl></div></body></html>