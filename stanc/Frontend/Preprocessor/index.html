<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Preprocessor (stanc.Frontend.Preprocessor)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">stanc</a> &#x00BB; <a href="../index.html">Frontend</a> &#x00BB; Preprocessor</nav><h1>Module <code>Frontend.Preprocessor</code></h1></header><aside><p>Preprocessor for handling include directives</p></aside><dl><dt class="spec value" id="val-current_buffer"><a href="#val-current_buffer" class="anchor"></a><code><span class="keyword">val</span> current_buffer : unit <span>&#45;&gt;</span> Stdlib.Lexing.lexbuf</code></dt><dd><p>Buffer at the top of the include stack</p></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val</span> size : unit <span>&#45;&gt;</span> int</code></dt><dd><p>Size of the include stack</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : Stdlib.Lexing.lexbuf <span>&#45;&gt;</span> unit</code></dt><dd><p>Push a buffer on to the stack to start</p></dd></dl><dl><dt class="spec value" id="val-update_start_positions"><a href="#val-update_start_positions" class="anchor"></a><code><span class="keyword">val</span> update_start_positions : Stdlib.Lexing.position <span>&#45;&gt;</span> unit</code></dt><dd><p>Update the lex_start_p the lexing buffers on the stack. This solves an issue where a parser which started with one lexbuf but is finishing with another can have the wrong information</p></dd></dl><dl><dt class="spec value" id="val-pop_buffer"><a href="#val-pop_buffer" class="anchor"></a><code><span class="keyword">val</span> pop_buffer : unit <span>&#45;&gt;</span> Stdlib.Lexing.lexbuf</code></dt><dd><p>Pop the buffer at the top of the include stack</p></dd></dl><dl><dt class="spec value" id="val-include_paths"><a href="#val-include_paths" class="anchor"></a><code><span class="keyword">val</span> include_paths : <span><span>string list</span> Core_kernel.ref</span></code></dt><dd><p>List of paths to search for including files</p></dd></dl><dl><dt class="spec value" id="val-included_files"><a href="#val-included_files" class="anchor"></a><code><span class="keyword">val</span> included_files : <span><span>string list</span> Core_kernel.ref</span></code></dt><dd><p>List of files that have been included</p></dd></dl><dl><dt class="spec value" id="val-restore_prior_lexbuf"><a href="#val-restore_prior_lexbuf" class="anchor"></a><code><span class="keyword">val</span> restore_prior_lexbuf : unit <span>&#45;&gt;</span> Stdlib.Lexing.lexbuf</code></dt><dd><p>Restore to a previous lexing buffer (assumes that one exists) and updates positions accordingly.</p></dd></dl><dl><dt class="spec value" id="val-try_get_new_lexbuf"><a href="#val-try_get_new_lexbuf" class="anchor"></a><code><span class="keyword">val</span> try_get_new_lexbuf : string <span>&#45;&gt;</span> Stdlib.Lexing.lexbuf</code></dt><dd><p>Search include paths for filename and try to create a new lexing buffer with that filename, record that included from specified position</p></dd></dl></div></body></html>