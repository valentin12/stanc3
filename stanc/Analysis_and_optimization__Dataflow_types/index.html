<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Analysis_and_optimization__Dataflow_types (stanc.Analysis_and_optimization__Dataflow_types)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">stanc</a> &#x00BB; Analysis_and_optimization__Dataflow_types</nav><h1>Module <code>Analysis_and_optimization__Dataflow_types</code></h1></header><dl><dt class="spec type" id="type-label"><a href="#type-label" class="anchor"></a><code><span class="keyword">type</span> label</code><code> = int</code></dt><dd><p>A label is a unique identifier for a node in the dataflow/dependency graph, and often corresponds to one node in the Mir.</p></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-label_of_sexp"><a href="#val-label_of_sexp" class="anchor"></a><code><span class="keyword">val</span> label_of_sexp : Ppx_sexp_conv_lib.Sexp.t <span>&#45;&gt;</span> <a href="index.html#type-label">label</a></code></dt><dt class="spec value" id="val-sexp_of_label"><a href="#val-sexp_of_label" class="anchor"></a><code><span class="keyword">val</span> sexp_of_label : <a href="index.html#type-label">label</a> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t</code></dt><dt class="spec value" id="val-hash_fold_label"><a href="#val-hash_fold_label" class="anchor"></a><code><span class="keyword">val</span> hash_fold_label : Ppx_hash_lib.Std.Hash.state <span>&#45;&gt;</span> <a href="index.html#type-label">label</a> <span>&#45;&gt;</span> Ppx_hash_lib.Std.Hash.state</code></dt><dt class="spec value" id="val-hash_label"><a href="#val-hash_label" class="anchor"></a><code><span class="keyword">val</span> hash_label : <a href="index.html#type-label">label</a> <span>&#45;&gt;</span> Ppx_hash_lib.Std.Hash.hash_value</code></dt><dt class="spec value" id="val-compare_label"><a href="#val-compare_label" class="anchor"></a><code><span class="keyword">val</span> compare_label : <a href="index.html#type-label">label</a> <span>&#45;&gt;</span> <a href="index.html#type-label">label</a> <span>&#45;&gt;</span> int</code></dt></dl></div></div></div><dl><dt class="spec type" id="type-vexpr"><a href="#type-vexpr" class="anchor"></a><code><span class="keyword">type</span> vexpr</code><code> = </code><table class="variant"><tr id="type-vexpr.VVar" class="anchored"><td class="def constructor"><a href="#type-vexpr.VVar" class="anchor"></a><code>| </code><code><span class="constructor">VVar</span> <span class="keyword">of</span> string</code></td></tr></table></dt><dd><p>Representation of an expression that can be assigned to. This should also be able to represent indexed variables, but we don't support that yet.</p></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-vexpr_of_sexp"><a href="#val-vexpr_of_sexp" class="anchor"></a><code><span class="keyword">val</span> vexpr_of_sexp : Ppx_sexp_conv_lib.Sexp.t <span>&#45;&gt;</span> <a href="index.html#type-vexpr">vexpr</a></code></dt><dt class="spec value" id="val-sexp_of_vexpr"><a href="#val-sexp_of_vexpr" class="anchor"></a><code><span class="keyword">val</span> sexp_of_vexpr : <a href="index.html#type-vexpr">vexpr</a> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t</code></dt><dt class="spec value" id="val-hash_fold_vexpr"><a href="#val-hash_fold_vexpr" class="anchor"></a><code><span class="keyword">val</span> hash_fold_vexpr : Ppx_hash_lib.Std.Hash.state <span>&#45;&gt;</span> <a href="index.html#type-vexpr">vexpr</a> <span>&#45;&gt;</span> Ppx_hash_lib.Std.Hash.state</code></dt><dt class="spec value" id="val-hash_vexpr"><a href="#val-hash_vexpr" class="anchor"></a><code><span class="keyword">val</span> hash_vexpr : <a href="index.html#type-vexpr">vexpr</a> <span>&#45;&gt;</span> Ppx_hash_lib.Std.Hash.hash_value</code></dt><dt class="spec value" id="val-compare_vexpr"><a href="#val-compare_vexpr" class="anchor"></a><code><span class="keyword">val</span> compare_vexpr : <a href="index.html#type-vexpr">vexpr</a> <span>&#45;&gt;</span> <a href="index.html#type-vexpr">vexpr</a> <span>&#45;&gt;</span> int</code></dt></dl></div></div></div><dl><dt class="spec type" id="type-reaching_defn"><a href="#type-reaching_defn" class="anchor"></a><code><span class="keyword">type</span> reaching_defn</code><code> = <a href="index.html#type-vexpr">vexpr</a> * <a href="index.html#type-label">label</a></code></dt><dd><p>A 'reaching definition' (or reaching_defn or RD) statement (v, l) says that the variable v could have been affected at the label l.</p></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-reaching_defn_of_sexp"><a href="#val-reaching_defn_of_sexp" class="anchor"></a><code><span class="keyword">val</span> reaching_defn_of_sexp : Ppx_sexp_conv_lib.Sexp.t <span>&#45;&gt;</span> <a href="index.html#type-reaching_defn">reaching_defn</a></code></dt><dt class="spec value" id="val-sexp_of_reaching_defn"><a href="#val-sexp_of_reaching_defn" class="anchor"></a><code><span class="keyword">val</span> sexp_of_reaching_defn : <a href="index.html#type-reaching_defn">reaching_defn</a> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t</code></dt><dt class="spec value" id="val-hash_fold_reaching_defn"><a href="#val-hash_fold_reaching_defn" class="anchor"></a><code><span class="keyword">val</span> hash_fold_reaching_defn : Ppx_hash_lib.Std.Hash.state <span>&#45;&gt;</span> <a href="index.html#type-reaching_defn">reaching_defn</a> <span>&#45;&gt;</span> Ppx_hash_lib.Std.Hash.state</code></dt><dt class="spec value" id="val-hash_reaching_defn"><a href="#val-hash_reaching_defn" class="anchor"></a><code><span class="keyword">val</span> hash_reaching_defn : <a href="index.html#type-reaching_defn">reaching_defn</a> <span>&#45;&gt;</span> Ppx_hash_lib.Std.Hash.hash_value</code></dt><dt class="spec value" id="val-compare_reaching_defn"><a href="#val-compare_reaching_defn" class="anchor"></a><code><span class="keyword">val</span> compare_reaching_defn : <a href="index.html#type-reaching_defn">reaching_defn</a> <span>&#45;&gt;</span> <a href="index.html#type-reaching_defn">reaching_defn</a> <span>&#45;&gt;</span> int</code></dt></dl></div></div></div><dl><dt class="spec type" id="type-source_loc"><a href="#type-source_loc" class="anchor"></a><code><span class="keyword">type</span> source_loc</code><code> = </code><table class="variant"><tr id="type-source_loc.MirNode" class="anchored"><td class="def constructor"><a href="#type-source_loc.MirNode" class="anchor"></a><code>| </code><code><span class="constructor">MirNode</span> <span class="keyword">of</span> <a href="../Middle/Location_span/index.html#type-t">Middle.Location_span.t</a></code></td></tr><tr id="type-source_loc.StartOfBlock" class="anchored"><td class="def constructor"><a href="#type-source_loc.StartOfBlock" class="anchor"></a><code>| </code><code><span class="constructor">StartOfBlock</span></code></td></tr><tr id="type-source_loc.TargetTerm" class="anchored"><td class="def constructor"><a href="#type-source_loc.TargetTerm" class="anchor"></a><code>| </code><code><span class="constructor">TargetTerm</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-source_loc.term" class="anchored"><td class="def field"><a href="#type-source_loc.term" class="anchor"></a><code>term : <a href="../Middle__Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a>;</code></td></tr><tr id="type-source_loc.assignment_label" class="anchored"><td class="def field"><a href="#type-source_loc.assignment_label" class="anchor"></a><code>assignment_label : <a href="index.html#type-label">label</a>;</code></td></tr></table><code>}</code></td></tr></table></dt><dd><p>Description of where a node in the dependency graph came from, where MirNode is the location from an Middle.loc_stmt</p></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-source_loc_of_sexp"><a href="#val-source_loc_of_sexp" class="anchor"></a><code><span class="keyword">val</span> source_loc_of_sexp : Ppx_sexp_conv_lib.Sexp.t <span>&#45;&gt;</span> <a href="index.html#type-source_loc">source_loc</a></code></dt><dt class="spec value" id="val-sexp_of_source_loc"><a href="#val-sexp_of_source_loc" class="anchor"></a><code><span class="keyword">val</span> sexp_of_source_loc : <a href="index.html#type-source_loc">source_loc</a> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t</code></dt></dl></div></div></div><dl><dt class="spec type" id="type-node_info"><a href="#type-node_info" class="anchor"></a><code><span class="keyword">type</span> <span>'rd_info node_info</span></code><code> = </code><code>{</code><table class="record"><tr id="type-node_info.rd_sets" class="anchored"><td class="def field"><a href="#type-node_info.rd_sets" class="anchor"></a><code>rd_sets : <span class="type-var">'rd_info</span>;</code></td></tr><tr id="type-node_info.possible_previous" class="anchored"><td class="def field"><a href="#type-node_info.possible_previous" class="anchor"></a><code>possible_previous : <span><a href="index.html#type-label">label</a> Core_kernel.Set.Poly.t</span>;</code></td></tr><tr id="type-node_info.rhs_set" class="anchored"><td class="def field"><a href="#type-node_info.rhs_set" class="anchor"></a><code>rhs_set : <span><a href="index.html#type-vexpr">vexpr</a> Core_kernel.Set.Poly.t</span>;</code></td></tr><tr id="type-node_info.controlflow" class="anchored"><td class="def field"><a href="#type-node_info.controlflow" class="anchor"></a><code>controlflow : <span><a href="index.html#type-label">label</a> Core_kernel.Set.Poly.t</span>;</code></td></tr><tr id="type-node_info.loc" class="anchored"><td class="def field"><a href="#type-node_info.loc" class="anchor"></a><code>loc : <a href="index.html#type-source_loc">source_loc</a>;</code></td></tr></table><code>}</code></dt><dd><p>Information to be collected about each node * rd_sets: Information about how the label effects the reaching definition sets * possible_previous: The set of nodes that could have immediately preceded this node under some execution of the program * rhs_set: The 'right hand side' set of variables that affect the value or behavior of this node * controlflow: The set of control flow nodes that are immediate parents of this node: * The most recent nested if/then or loop, * or the beginning of the function or block if there are no containing branches, * plus the set of relevant continue/return statements, * plus, for loops, any break statements they contain * loc: The location of the Mir node that this node corresponds to, or a description if there is none</p></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-node_info_of_sexp"><a href="#val-node_info_of_sexp" class="anchor"></a><code><span class="keyword">val</span> node_info_of_sexp : rd_info. <span>(Ppx_sexp_conv_lib.Sexp.t <span>&#45;&gt;</span> <span class="type-var">'rd_info</span>)</span> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t <span>&#45;&gt;</span> <span><span class="type-var">'rd_info</span> <a href="index.html#type-node_info">node_info</a></span></code></dt><dt class="spec value" id="val-sexp_of_node_info"><a href="#val-sexp_of_node_info" class="anchor"></a><code><span class="keyword">val</span> sexp_of_node_info : rd_info. <span>(<span class="type-var">'rd_info</span> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t)</span> <span>&#45;&gt;</span> <span><span class="type-var">'rd_info</span> <a href="index.html#type-node_info">node_info</a></span> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t</code></dt></dl></div></div></div><dl><dt class="spec type" id="type-node_info_update"><a href="#type-node_info_update" class="anchor"></a><code><span class="keyword">type</span> node_info_update</code><code> = <span><span>(<span><a href="index.html#type-reaching_defn">reaching_defn</a> Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <span><a href="index.html#type-reaching_defn">reaching_defn</a> Core_kernel.Set.Poly.t</span>)</span> <a href="index.html#type-node_info">node_info</a></span></code></dt><dd><p>A node_info, where the reaching definition information takes the form of an update function that maps from the 'entry' set to the 'exit' set, where the entry set is what's true before executing this node and the exit set is true after.</p></dd></dl><dl><dt class="spec type" id="type-node_info_fixedpoint"><a href="#type-node_info_fixedpoint" class="anchor"></a><code><span class="keyword">type</span> node_info_fixedpoint</code><code> = <span><span>(<span><a href="index.html#type-reaching_defn">reaching_defn</a> Core_kernel.Set.Poly.t</span> * <span><a href="index.html#type-reaching_defn">reaching_defn</a> Core_kernel.Set.Poly.t</span>)</span> <a href="index.html#type-node_info">node_info</a></span></code></dt><dd><p>A node_info where the reaching definition information is explicitly written as the entry and exit sets, as after finding the fixed-point solution.</p></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-node_info_fixedpoint_of_sexp"><a href="#val-node_info_fixedpoint_of_sexp" class="anchor"></a><code><span class="keyword">val</span> node_info_fixedpoint_of_sexp : Ppx_sexp_conv_lib.Sexp.t <span>&#45;&gt;</span> <a href="index.html#type-node_info_fixedpoint">node_info_fixedpoint</a></code></dt><dt class="spec value" id="val-sexp_of_node_info_fixedpoint"><a href="#val-sexp_of_node_info_fixedpoint" class="anchor"></a><code><span class="keyword">val</span> sexp_of_node_info_fixedpoint : <a href="index.html#type-node_info_fixedpoint">node_info_fixedpoint</a> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t</code></dt></dl></div></div></div><dl><dt class="spec type" id="type-traversal_state"><a href="#type-traversal_state" class="anchor"></a><code><span class="keyword">type</span> traversal_state</code><code> = </code><code>{</code><table class="record"><tr id="type-traversal_state.label_ix" class="anchored"><td class="def field"><a href="#type-traversal_state.label_ix" class="anchor"></a><code>label_ix : <a href="index.html#type-label">label</a>;</code></td></tr><tr id="type-traversal_state.node_info_map" class="anchored"><td class="def field"><a href="#type-traversal_state.node_info_map" class="anchor"></a><code>node_info_map : <span><span>(int,Â <a href="index.html#type-node_info_update">node_info_update</a>)</span> Core_kernel.Map.Poly.t</span>;</code></td></tr><tr id="type-traversal_state.possible_previous" class="anchored"><td class="def field"><a href="#type-traversal_state.possible_previous" class="anchor"></a><code>possible_previous : <span><a href="index.html#type-label">label</a> Core_kernel.Set.Poly.t</span>;</code></td></tr><tr id="type-traversal_state.target_terms" class="anchored"><td class="def field"><a href="#type-traversal_state.target_terms" class="anchor"></a><code>target_terms : <span><a href="index.html#type-label">label</a> Core_kernel.Set.Poly.t</span>;</code></td></tr><tr id="type-traversal_state.continues" class="anchored"><td class="def field"><a href="#type-traversal_state.continues" class="anchor"></a><code>continues : <span><a href="index.html#type-label">label</a> Core_kernel.Set.Poly.t</span>;</code></td></tr><tr id="type-traversal_state.breaks" class="anchored"><td class="def field"><a href="#type-traversal_state.breaks" class="anchor"></a><code>breaks : <span><a href="index.html#type-label">label</a> Core_kernel.Set.Poly.t</span>;</code></td></tr><tr id="type-traversal_state.returns" class="anchored"><td class="def field"><a href="#type-traversal_state.returns" class="anchor"></a><code>returns : <span><a href="index.html#type-label">label</a> Core_kernel.Set.Poly.t</span>;</code></td></tr><tr id="type-traversal_state.rejects" class="anchored"><td class="def field"><a href="#type-traversal_state.rejects" class="anchor"></a><code>rejects : <span><a href="index.html#type-label">label</a> Core_kernel.Set.Poly.t</span>;</code></td></tr></table><code>}</code></dt><dd><p>The state that will be maintained throughout the traversal of the Mir * label_ix: The next label that's free to use * node_info_map: The label information that's been built so far * possible_previous: The set of nodes that could have immediately preceded this point under some execution of the program * target_terms: The set of nodes that correspond to terms added to the target variable * continues: A set of the continue nodes that have been encountered since exiting a loop * breaks: A set of the break nodes that have been encountered since exiting a loop * returns: A set of the return nodes that have been encountered</p></dd></dl><dl><dt class="spec type" id="type-cf_state"><a href="#type-cf_state" class="anchor"></a><code><span class="keyword">type</span> cf_state</code><code> = <a href="index.html#type-label">label</a></code></dt><dd><p>The most recently nested control flow (block start, if/then, or loop)</p><p>This isn't included in the traversal_state because it only flows downward through the tree, not across and up like everything else</p></dd></dl><dl><dt class="spec type" id="type-dataflow_graph"><a href="#type-dataflow_graph" class="anchor"></a><code><span class="keyword">type</span> dataflow_graph</code><code> = </code><code>{</code><table class="record"><tr id="type-dataflow_graph.node_info_map" class="anchored"><td class="def field"><a href="#type-dataflow_graph.node_info_map" class="anchor"></a><code>node_info_map : <span><span>(int,Â <a href="index.html#type-node_info_fixedpoint">node_info_fixedpoint</a>)</span> Core_kernel.Map.Poly.t</span>;</code></td></tr><tr id="type-dataflow_graph.possible_exits" class="anchored"><td class="def field"><a href="#type-dataflow_graph.possible_exits" class="anchor"></a><code>possible_exits : <span><a href="index.html#type-label">label</a> Core_kernel.Set.Poly.t</span>;</code></td></tr><tr id="type-dataflow_graph.probabilistic_nodes" class="anchored"><td class="def field"><a href="#type-dataflow_graph.probabilistic_nodes" class="anchor"></a><code>probabilistic_nodes : <span><a href="index.html#type-label">label</a> Core_kernel.Set.Poly.t</span>;</code></td></tr></table><code>}</code></dt><dd><p>Everything we need to know to do dependency analysis * node_info_map: Collection of node information * possible_exits: Set of nodes that could be the last to execute under some execution * probabilistic_nodes: Set of nodes corresponding to which can only introduce probabilistic dependencies, such as target terms and reject statements, to be excluded for non-statistical dependency analysis</p></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-dataflow_graph_of_sexp"><a href="#val-dataflow_graph_of_sexp" class="anchor"></a><code><span class="keyword">val</span> dataflow_graph_of_sexp : Ppx_sexp_conv_lib.Sexp.t <span>&#45;&gt;</span> <a href="index.html#type-dataflow_graph">dataflow_graph</a></code></dt><dt class="spec value" id="val-sexp_of_dataflow_graph"><a href="#val-sexp_of_dataflow_graph" class="anchor"></a><code><span class="keyword">val</span> sexp_of_dataflow_graph : <a href="index.html#type-dataflow_graph">dataflow_graph</a> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t</code></dt></dl></div></div></div><dl><dt class="spec type" id="type-prog_df_graphs"><a href="#type-prog_df_graphs" class="anchor"></a><code><span class="keyword">type</span> prog_df_graphs</code><code> = </code><code>{</code><table class="record"><tr id="type-prog_df_graphs.tdatab" class="anchored"><td class="def field"><a href="#type-prog_df_graphs.tdatab" class="anchor"></a><code>tdatab : <a href="index.html#type-dataflow_graph">dataflow_graph</a>;</code></td></tr><tr id="type-prog_df_graphs.modelb" class="anchored"><td class="def field"><a href="#type-prog_df_graphs.modelb" class="anchor"></a><code>modelb : <a href="index.html#type-dataflow_graph">dataflow_graph</a>;</code></td></tr><tr id="type-prog_df_graphs.gqb" class="anchored"><td class="def field"><a href="#type-prog_df_graphs.gqb" class="anchor"></a><code>gqb : <a href="index.html#type-dataflow_graph">dataflow_graph</a>;</code></td></tr></table><code>}</code></dt><dd><p>Represents the dataflow graphs for each interesting block in the program MIR.</p><p>See Middle.prog for block descriptions.</p></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-prog_df_graphs_of_sexp"><a href="#val-prog_df_graphs_of_sexp" class="anchor"></a><code><span class="keyword">val</span> prog_df_graphs_of_sexp : Ppx_sexp_conv_lib.Sexp.t <span>&#45;&gt;</span> <a href="index.html#type-prog_df_graphs">prog_df_graphs</a></code></dt><dt class="spec value" id="val-sexp_of_prog_df_graphs"><a href="#val-sexp_of_prog_df_graphs" class="anchor"></a><code><span class="keyword">val</span> sexp_of_prog_df_graphs : <a href="index.html#type-prog_df_graphs">prog_df_graphs</a> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t</code></dt></dl></div></div></div></div></body></html>